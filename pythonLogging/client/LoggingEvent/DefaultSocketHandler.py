import logging
import logging.handlers
import socket
import struct

LOGGING_EVENT = (
	0x72, 0x00, 0x21,
	0x6F, 0x72, 0x67, 0x2E, 0x61, 0x70, 0x61, 0x63,
	0x68, 0x65, 0x2E, 0x6C, 0x6F, 0x67, 0x34, 0x6A,
	0x2E, 0x73, 0x70, 0x69, 0x2E, 0x4C, 0x6F, 0x67,
	0x67, 0x69, 0x6E, 0x67, 0x45, 0x76, 0x65, 0x6E,
	0x74, 0xF3, 0xF2, 0xB9, 0x23, 0x74, 0x0B, 0xB5,
	0x3F, 0x03, 0x00, 0x0A, 0x5A, 0x00, 0x15, 0x6D,
	0x64, 0x63, 0x43, 0x6F, 0x70, 0x79, 0x4C, 0x6F,
	0x6F, 0x6B, 0x75, 0x70, 0x52, 0x65, 0x71, 0x75,
	0x69, 0x72, 0x65, 0x64, 0x5A, 0x00, 0x11, 0x6E,
	0x64, 0x63, 0x4C, 0x6F, 0x6F, 0x6B, 0x75, 0x70,
	0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64,
	0x4A, 0x00, 0x09, 0x74, 0x69, 0x6D, 0x65, 0x53,
	0x74, 0x61, 0x6D, 0x70, 0x4C, 0x00, 0x0C, 0x63,
	0x61, 0x74, 0x65, 0x67, 0x6F, 0x72, 0x79, 0x4E,
	0x61, 0x6D, 0x65, 0x74, 0x00, 0x12, 0x4C, 0x6A,
	0x61, 0x76, 0x61, 0x2F, 0x6C, 0x61, 0x6E, 0x67,
	0x2F, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3B,
	0x4C, 0x00, 0x0C, 0x6C, 0x6F, 0x63, 0x61, 0x74,
	0x69, 0x6F, 0x6E, 0x49, 0x6E, 0x66, 0x6F, 0x74,
	0x00, 0x23, 0x4C, 0x6F, 0x72, 0x67, 0x2F, 0x61,
	0x70, 0x61, 0x63, 0x68, 0x65, 0x2F, 0x6C, 0x6F,
	0x67, 0x34, 0x6A, 0x2F, 0x73, 0x70, 0x69, 0x2F,
	0x4C, 0x6F, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E,
	0x49, 0x6E, 0x66, 0x6F, 0x3B, 0x4C, 0x00, 0x07,
	0x6D, 0x64, 0x63, 0x43, 0x6F, 0x70, 0x79, 0x74,
	0x00, 0x15, 0x4C, 0x6A, 0x61, 0x76, 0x61, 0x2F,
	0x75, 0x74, 0x69, 0x6C, 0x2F, 0x48, 0x61, 0x73,
	0x68, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x3B, 0x4C,
	0x00, 0x03, 0x6E, 0x64, 0x63,
	0x74, 0x00, 0x12, 0x4C, 0x6A,
	0x61, 0x76, 0x61, 0x2F, 0x6C, 0x61, 0x6E, 0x67,
	0x2F, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3B,
	0x4C, 0x00, 0x0F, 0x72, 0x65, 0x6E,
	0x64, 0x65, 0x72, 0x65, 0x64, 0x4D, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65,
	0x74, 0x00, 0x12, 0x4C, 0x6A,
	0x61, 0x76, 0x61, 0x2F, 0x6C, 0x61, 0x6E, 0x67,
	0x2F, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3B,
	0x4C, 0x00, 0x0A, 0x74, 0x68, 0x72, 0x65,
	0x61, 0x64, 0x4E, 0x61, 0x6D, 0x65,
	0x74, 0x00, 0x12, 0x4C, 0x6A,
	0x61, 0x76, 0x61, 0x2F, 0x6C, 0x61, 0x6E, 0x67,
	0x2F, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3B,
	0x4C, 0x00, 0x0D, 0x74, 0x68,
	0x72, 0x6F, 0x77, 0x61, 0x62, 0x6C, 0x65, 0x49,
	0x6E, 0x66, 0x6F, 0x74, 0x00, 0x2B, 0x4C, 0x6F,
	0x72, 0x67, 0x2F, 0x61, 0x70, 0x61, 0x63, 0x68,
	0x65, 0x2F, 0x6C, 0x6F, 0x67, 0x34, 0x6A, 0x2F,
	0x73, 0x70, 0x69, 0x2F, 0x54, 0x68, 0x72, 0x6F,
	0x77, 0x61, 0x62, 0x6C, 0x65, 0x49, 0x6E, 0x66,
	0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E,
	0x3B, 0x78, 0x70
)

LOCATION_INFO = (
	0x72, 0x00, 0x21, 0x6F, 0x72, 0x67, 0x2E,
	0x61, 0x70, 0x61, 0x63, 0x68, 0x65, 0x2E, 0x6C,
	0x6F, 0x67, 0x34, 0x6A, 0x2E, 0x73, 0x70, 0x69,
	0x2E, 0x4C, 0x6F, 0x63, 0x61, 0x74, 0x69, 0x6F,
	0x6E, 0x49, 0x6E, 0x66, 0x6F, 0xED, 0x99, 0xBB,
	0xE1, 0x4A, 0x91, 0xA5, 0x7C, 0x02, 0x00, 0x01,
	0x4C, 0x00, 0x08, 0x66, 0x75, 0x6C, 0x6C, 0x49,
	0x6E, 0x66, 0x6F,
	0x74, 0x00, 0x12, 0x4C, 0x6A,
	0x61, 0x76, 0x61, 0x2F, 0x6C, 0x61, 0x6E, 0x67,
	0x2F, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3B,
	0x78, 0x70
)

TC_NULL = b'\x70' # !!! b'\0x70' 형식은 안됨
TC_REFERENCE = b'\x71'
TC_CLASSDESC = b'\x72'
TC_OBJECT = b'\x73'
TC_STRING = b'\x74'
TC_ARRAY = b'\x75'
TC_CLASS = b'\x76'
TC_BLOCKDATA = b'\x77'
TC_ENDBLOCKDATA = b'\x78'

DEFAULT_START_FLAG = b"\xAC\xED\x00\x05"

#####
# DefaultSocketHandler
#####
class DefaultSocketHandler(logging.handlers.SocketHandler):
	"""description of class"""
	def __init__(self, host, port):
		super().__init__(host, port)

	# 연결시 시작 flag를 보낸다.
	def makeSocket(self, timeout=1):
		clientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		try:
			clientSocket.connect(self.address)
			clientSocket.send(DEFAULT_START_FLAG)
		except OSError as e:
			clientSocket.close()
			raise
		return clientSocket

	# LogRecord 필요한 데이터 바이트 전송
	def makePickle(self, record : logging.LogRecord) -> bytes:
		name = record.name.encode(); nameLen = len(name)
		msg = record.msg.encode(); msgLen = len(msg)
		threadName = record.threadName.encode(); threadNameLen = len(threadName)
		fullInfo = record.funcName + "(" + record.pathname + ":" + str(record.lineno) + ")"
		fullInfo = fullInfo.encode(); fullInfoLen = len(fullInfo)

		# LoggingEvent::write(helpers::ObjectOutputStream& os, Pool& p)
		# os.writeProlog("org.apache.log4j.spi.LoggingEvent", 8, classDesc, sizeof(classDesc), p);
		data = TC_OBJECT
		# TC_CLASSDESC
		data += bytes(LOGGING_EVENT)

		# os.writeBytes(lookupsRequired, sizeof(lookupsRequired), p);
		lookupsRequired = (0, 0)
		data += bytes(lookupsRequired)

		# os.writeLong(timeStamp/1000, p);
		data += struct.pack('! Q', round(record.created * 1000))

		# os.writeObject(logger, p);
		data += TC_STRING
		data += struct.pack("! h %ds" % (nameLen), nameLen, name)

		# locationInfo.write(os, p);
		# os.writeProlog("org.apache.log4j.spi.LocationInfo", 2, prolog, sizeof(prolog), p);
		data += TC_OBJECT;
		# TC_CLASSDESC
		data += bytes(LOCATION_INFO)

		# os.writeUTFString(fullInfo, p);
		data += TC_STRING;
		data += struct.pack("! h %ds" % (fullInfoLen), fullInfoLen, fullInfo)

		# mdc
		data += TC_NULL

		# ndc
		data += TC_NULL

		# os.writeObject(message, p);
		data += TC_STRING;
		data += struct.pack("! h %ds" % (msgLen), msgLen, msg)

		# os.writeObject(threadName, p);
		data += TC_STRING;
		data += struct.pack("! h %ds" % (threadNameLen), threadNameLen, threadName)

		# os.writeNull(p);
		data += TC_NULL

		# os.writeByte(ObjectOutputStream::TC_BLOCKDATA, p);
		data += TC_BLOCKDATA

		# os.writeByte(0x04, p);
		data += b'\x04'

		# os.writeInt(level->toInt(), p);
		data += struct.pack("! I", int(record.levelno) * 1000)

		# os.writeNull(p);
		data += TC_NULL

		# os.writeByte(ObjectOutputStream::TC_ENDBLOCKDATA, p);
		data += TC_ENDBLOCKDATA
		
		return data
